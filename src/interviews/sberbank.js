/*
  Считается, что число A находится строго между B и C, если оно удовлетворяет следующему неравенству: B < A < C или B > A > C

  Элементы массива A с индексами P и Q называются смежными, если не существует ни одного такого элемента в массиве A, значение которого лежало бы между ними и A[P] != A[Q]. Пару индексов (P, Q) будем называть дуплексом.

  Расстояние между индексами в дуплексе считается по формуле |P-Q|.

  Напишите функцию, которая на вход получает не пустой массив A, состоящий из N чисел, и возвращает наибольшее «расстояние» между индексами в дуплексах. Если дуплексов в массиве не существует, то функция должна вернуть -1.

  Например, есть массив A:
  A [0] = 1
  A [1] = 4
  A [2] = 7
  A [3] = 3
  A [4] = 3
  A [5] = 5

  Функция должна вернуть 4 т.к.:
  Индексы 0 и 4 составляют дуплекс потому, что A[0] != A[4], и массив не содержит значений, которые находились бы строго между A[0] = 1 и A[4] = 3;
  Расстояние между этими индексами равно |0 - 4| = 4
  Нет ни одного дуплекса и дистанцией больше

  Доп. условия:
  Считайте, что N это целое число в диапазоне [1 … 40 000]
  Каждый элемент в массиве A находится в диапазоне [-2 147 283 648 … 2 147 483 647]
  Сложность по времени в худшем случае должна составлять O(N*log(N))
  Сложность по памяти в худшем случае должно составлять O( N )
*/

/*
*  Решение:
*   - Обрезаем массив попеременно то по первому, то по последнему элементу, тк это будет наибольшее рассточяние между индексами.
*   - Продолжаем до тех пор пока не найдем наибольшее расстояние.
* */
function duplex(A){
  let arr = A.slice();
  let result = -1;
  let first_splice = true;
  let first = null;
  let last = arr.pop();
  while(arr.length !== 0){
    if(first_splice){
      first = arr.shift();
      first_splice = false;
    }else{
      last = arr.pop();
      first_splice = true;
    }
    if(first === last){
      continue;
    }
    if(arr.every(item => (first <= item) && (last <= item))){
      result = arr.length + 1;
      break;
    }
    if(arr.every(item => (first >= item) && (last >= item))){
      result = arr.length + 1;
      break;
    }
  }
  return result;
}

let A = [1, 4, 7, 3, 3, 5];
console.log(duplex(A));
// alert(duplex(A));